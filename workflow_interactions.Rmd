---
title: "Identifying interaction workflow"
author: "Andrea Zermeño Díaz"
date: "`r Sys.Date()`"
output: html_document
---

Workflow of how to identify interaction patterns between ocean microbial phylogenetic groups and biosynthetic gene clusters (BGCs).

```{r libraries, warning=FALSE, message=FALSE}
library(tidyverse)
library(dplyr)
```

***Metadata was prepared in ExploratoryAnalyisis_omd.Rmd***
```{r load_data}
setwd("~/MAGs_BGCs_interactions")
meta_mags <- read.csv("metadata.csv")
meta_bgcs <- read.csv("bgcs_metadata.csv")

# We are grouping by mOTUS so we need to omit the NAs / For other categories skip this 
meta_mags <- meta_mags %>% filter(!is.na(mOTUs_Species_Cluster))
meta_bgcs <- meta_bgcs %>%
  filter(Genome %in% meta_mags$Genome)
```

Count the number of Metagenome Assembled Genomes (MAGs) per site and the microbial phylogenetic group, for this try we will classify groups by mOTUs. Also for group the BGCs we will use the gene cluster families (GCFs).

```{r count_mags}
# number of mOTUs
#motus <- meta_mags %>% 
#  distinct(mOTUs.Species.Cluster)

# Count the number of MAGs per site and mOTUs
motus_by_sites <- meta_mags %>%
  count(station, mOTUs_Species_Cluster) %>%
  pivot_wider(names_from = mOTUs_Species_Cluster, values_from = n, values_fill = 0)
```

Add the locations to the BGCs table based on the MAGs from where they were found and count the number of BGCs per site and GCF.

```{r count_bgcs}
# bind the column station to each BGC using the column Genome ass a reference to match it 
bgcs_sites <- meta_bgcs %>%
  left_join(meta_mags %>% select(Genome, station), by = "Genome")

# number of GCFs 
#gcfs <- bgcs_sites %>% 
#  distinct(gcf)

# count the number of BGCs per site and GCF
gcfs_by_sites <- bgcs_sites %>%
  count(station, gcf) %>%
  pivot_wider(names_from = gcf, values_from = n, values_fill = 0) 
```

Now we need bind each column of the `gcfs_by_sites` table with each column of the `motus_by_sytes` table,  5,138 x 3,934 tables (20,212,892)  of 3 columns (stations, mOTUs and GCFs) and 256 rows dictated by station will be generated. This will help us to identify "co-exclusion" and "co-occurrence" patterns, combinations that dont follow up the patterns will be discarted. 

```{r funcition}
# function
recreate_table <- function(mag, bgc, motus_by_sites, gcfs_by_sites) {

  # select the station column and the current column for both tables
  table1 <- motus_by_sites[, c("station", mag), drop = FALSE]
  table2 <- gcfs_by_sites[, c("station", bgc), drop = FALSE]
  
  # bind col1 and col2 by station (full_join porque sino se pierden interacciones)
  table_comb <- full_join(table1, table2, by = "station")
  
  # convert NAs to 0 generated in the join
  table_comb[[mag]] <- ifelse(is.na(table_comb[[mag]]), 0, table_comb[[mag]])
  table_comb[[bgc]] <- ifelse(is.na(table_comb[[bgc]]), 0, table_comb[[bgc]])
  
  # eliminate lines were both values are 0
  table_comb <- table_comb[!(table_comb[[mag]] == 0 & table_comb[[bgc]] == 0), ]
  
  return(table_comb)
}

# Example of use:
example <- recreate_table("gom_000200", "gcf_1033", motus_by_sites, gcfs_by_sites)
print(example)

```

***Checking the code with an example in try.Rmd***

```{r}
# tables to save the interactions
co_occur <- data.frame(mags = character(), bgcs = character(), total_sites = integer(), 
                       stringsAsFactors = FALSE)

co_exclu <- data.frame(mags = character(), bgcs = character(), total_sites = integer(), 
                       mag_sites= integer(), bgc_sites = integer(), stringsAsFactors = FALSE)

for (col1 in colnames(motus_by_sites)) {
  if (col1 == "station") next  # Ignoring station column
  
  for (col2 in colnames(gcfs_by_sites)) {
    if (col2 == "station") next  
    
    # function calling
    temp3 <- recreate_table(col1, col2, motus_by_sites, gcfs_by_sites)

    if (nrow(temp3) == 0) next 
    
    # co-occurrence
    if (all((temp3[[col1]] > 0) == (temp3[[col2]] > 0))) {
      #add new row
      co_occur <- rbind(co_occur, data.frame(mags= col1, bgcs= col2, total_sites= nrow(temp3)))
      
    }
    # co-exclusion
    if (all((temp3[[col1]] == 0 & temp3[[col2]] > 0) | (temp3[[col1]] > 0 & temp3[[col2]] == 0))) { 
      
      mags_sum <- sum(temp3[[col1]] > 0) # how many sites have mags
      bgcs_sum <- sum(temp3[[col2]] > 0) # vs. how many sites have bgcs
      #add new row
      co_exclu <- rbind(co_exclu, data.frame(mags= col1, bgcs= col2, total_sites= nrow(temp3), 
                                             mag_sites = mags_sum, bgc_sites = bgcs_sum ))
    }
  }
}


#write.csv(co_exclu, file = "co_exclussion.csv", row.names = FALSE)
#write.csv(co_occur, file = "co_occurrence.csv", row.names = FALSE)


```
***The final code is in workflow_interactions.r***

10⁸ patrones de co-exclusion perfectos fueron encontrados. 
10⁵ patrones de co-ocurrencia perfectos fueron encotrados.

Muchos patrones ocurren solo en pocos sitios, lo cual no es tan interesante.
***Ir a graphs.Rmd para ver sus distribuciones y otras cosas***
```{r filt, eval=FALSE}
# para saber las interaccions que ocurren en mas sitios
top_10_co_exclu <- co_exclu[order(-co_exclu$num_stations), ][1:10, ]
print(top_10_co_exclu)

# para filtrar segun los sitios
filt_exclu <- co_exclu %>%
  filter(total_sites > 50)
filt_ocur <- co_ocur %>%
  filter(total_sites > 50)

# radio entre sitios con mags y sitios con bgcs para casos de co-exclusion, que esten cerca de 0
ratio_plot <- filt_exclu %>%
  mutate(
    ratio = log2(mag_sites / bgc_sites)  # pseudoconteo para evitar log(0)
  )

# eliminar casos de co-ocurrencia donde el bgc pertenezca al mismo mag
meta_bgcs <- meta_bgcs %>%    # agregar columna de motus a meta_bgcs 
  left_join(meta_mags %>% select(Genome, mOTUs_Species_Cluster), by = "Genome")

filt_ocur <- filt_ocur %>%  #filtrar
  anti_join(meta_bgcs, by = c("Mags" = "mOTUs_Species_Cluster", "Bgcs" = "gcf"))

```

#---------------------------------------
#          PROBABILITIES
#---------------------------------------
We need to calculate de probability of each case so we can 

***Exploring this in try1.Rmd***
```{r probs}
# significance with binomial test 
# res<- co_ocurr %>%
#   rowwise() %>%
#   mutate(
#     test = list(binom.test(total, n_sites, p = 0.5)),  # hipótesis nula p=0.5
#     p_value = test$p.value
#   ) %>%
#   ungroup()

# model
# n_sites <- 256
# 
# modelo <- glm(cbind(total_sites, n_sites - total_sites) ~ Mags + Bgcs,
#               data = co_ocur,
#               family = binomial)
# summary(modelo)

n_sites <- length(unique(motus_by_sites$station)) # numero total de sitios

# probabilidad de que ocurra una co-exclusion
prob_exlcu <- co_exclu %>%
  mutate(
    # P(mag = 1)
    q = mag_sites/n_sites,
    # P(bgc = 1)
    p = bgc_sites/n_sites,
    # pi = P(mag = 1, bgc = 0) + P(mag = 0, bgc = 1) = (p)*(1-q) + (q)*(1-p) = p-(2*p*q)+q
    pi = p - (2*p*q) + q ,
  )

# probabilidad de que ocurra una co-ocurrencia
stats_ocur <- co_occur %>%
  mutate(
    # P(mag = 1)
    q = mag_sites/n_sites,
    # P(bgc = 1)
    p = bgc_sites/n_sites,
    # pi = P(mag = 1, bgc = 1) = p * q    
    pi = p * q    # p = q si es co-ocurrencia perfecta 
  )


```

#----------------------------------------
#            BINOMIAL TEST
#----------------------------------------
Now that we have the probabilities we can calculates de p-value with a binomial test to see if the case is significant
```{r binom}

```




#---------------------------------------------------------------------------
this part is only to check the distribution of groups

```{r check, eval=FALSE}
# 1138 mOTUs of only 1 MAG representative 
meta_mags %>%
  group_by(mOTUs.Species.Cluster) %>%                     
  summarise(n = n()) %>%                 
  filter(n == 1)  
# 2564 gcfs of only 1 BGC representative 
bgcs_sites %>%
  group_by(gcf) %>%                     
  summarise(n = n()) %>%                 
  filter(n == 1)  

names(which(table(meta_mags$mOTUs.Species.Cluster) == 1))



setdiff(motus_by_sites$station, gcfs_by_sites$station)
setdiff(meta_mags$station, bgcs_sites$station)
```




