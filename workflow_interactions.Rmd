---
title: "Identifying interaction workflow"
author: "Andrea Zermeño Díaz"
date: "`r Sys.Date()`"
output: html_document
---

Workflow of how to identify interaction patterns between ocean microbial phylogenetic groups and biosynthetic gene clusters (BGCs).

```{r libraries, warning=FALSE, message=FALSE}
library(tidyverse)
library(dplyr)
```

```{r load_data}
setwd("~/MAGs_BGCs_interactions")
meta_mags <- read.csv("metadata.csv")
meta_bgcs <- read.csv("bgcs_metadata.csv")

# We are grouping by mOTUS so we need to omit the NAs / For other categories skip this 
meta_mags <- meta_mags %>% filter(!is.na(mOTUs_Species_Cluster))
meta_bgcs <- meta_bgcs %>%
  filter(Genome %in% meta_mags$Genome)
```

Count the number of Metagenome Assembled Genomes (MAGs) per site and the microbial phylogenetic group, for this try we will classify groups by mOTUs. Also for group the BGCs we will use the gene cluster families (GCFs).

```{r count_mags}
# number of mOTUs
#motus <- meta_mags %>% 
#  distinct(mOTUs.Species.Cluster)

# Count the number of MAGs per site and mOTUs
motus_by_sites <- meta_mags %>%
  count(station, mOTUs_Species_Cluster) %>%
  pivot_wider(names_from = mOTUs_Species_Cluster, values_from = n, values_fill = 0)
```

Add the locations to the BGCs table based on the MAGs from where they were found and count the number of BGCs per site and GCF.

```{r count_bgcs}
# bind the column station to each BGC using the column Genome ass a reference to match it 
bgcs_sites <- meta_bgcs %>%
  left_join(meta_mags %>% select(Genome, station), by = "Genome")

# number of GCFs 
#gcfs <- bgcs_sites %>% 
#  distinct(gcf)

# count the number of BGCs per site and GCF
gcfs_by_sites <- bgcs_sites %>%
  count(station, gcf) %>%
  pivot_wider(names_from = gcf, values_from = n, values_fill = 0) 
```

Now we need bind each column of the `gcfs_by_sites` table with each column of the `motus_by_sytes` table,  5,138 x 3,934 tables (20,212,892)  of 3 columns (stations, mOTUs and GCFs) and 256 rows dictated by station will be generated. This will help us to identify "co-exclusion" and "co-occurrence" patterns, combinations that dont follow up the patterns will be discarted. 

```{r funcition}
# function
recreate_table <- function(mag, bgc, motus_by_sites, gcfs_by_sites) {

  # select the station column and the current column for both tables
  table1 <- motus_by_sites[, c("station", mag), drop = FALSE]
  table2 <- gcfs_by_sites[, c("station", bgc), drop = FALSE]
  
  # bind col1 and col2 by station (full_join porque sino se pierden interacciones)
  table_comb <- full_join(table1, table2, by = "station")
  
  # convert NAs to 0 generated in the join
  table_comb[[mag]] <- ifelse(is.na(table_comb[[mag]]), 0, table_comb[[mag]])
  table_comb[[bgc]] <- ifelse(is.na(table_comb[[bgc]]), 0, table_comb[[bgc]])
  
  # eliminate lines were both values are 0
  table_comb <- table_comb[!(table_comb[[mag]] == 0 & table_comb[[bgc]] == 0), ]
  
  return(table_comb)
}

# Example of use:
example <- recreate_table("gom_000200", "gcf_1033", motus_by_sites, gcfs_by_sites)
print(example)

```

```{r}
# tables to save the interactions
co_occur <- data.frame(mags = character(), bgcs = character(), total_sites = integer(), 
                       stringsAsFactors = FALSE)

co_exclu <- data.frame(mags = character(), bgcs = character(), total_sites = integer(), 
                       mag_sites= integer(), bgc_sites = integer(), stringsAsFactors = FALSE)

for (col1 in colnames(motus_by_sites)) {
  if (col1 == "station") next  # Ignoring station column
  
  for (col2 in colnames(gcfs_by_sites)) {
    if (col2 == "station") next  
    
    # function calling
    temp3 <- recreate_table(col1, col2, motus_by_sites, gcfs_by_sites)

    if (nrow(temp3) == 0) next 
    
    # co-occurrence
    if (all((temp3[[col1]] > 0) == (temp3[[col2]] > 0))) {
      #add new row
      co_occur <- rbind(co_occur, data.frame(mags= col1, bgcs= col2, total_sites= nrow(temp3)))
      
    }
    # co-exclusion
    if (all((temp3[[col1]] == 0 & temp3[[col2]] > 0) | (temp3[[col1]] > 0 & temp3[[col2]] == 0))) { 
      
      mags_sum <- sum(temp3[[col1]] > 0) # how many sites have mags
      bgcs_sum <- sum(temp3[[col2]] > 0) # vs. how many sites have bgcs
      #add new row
      co_exclu <- rbind(co_exclu, data.frame(mags= col1, bgcs= col2, total_sites= nrow(temp3), 
                                             mag_sites = mags_sum, bgc_sites = bgcs_sum ))
    }
  }
}


#write.csv(co_exclu, file = "co_exclussion.csv", row.names = FALSE)
#write.csv(co_occur, file = "co_occurrence.csv", row.names = FALSE)


```


```{r filt, eval=FALSE}
# para saber las interaccions que ocurren en mas sitios

top_10_co_exclu <- co_exclu[order(-co_exclu$num_stations), ][1:10, ]
print(top_10_co_exclu)

# para filtrar segun los sitios
filt_exclu <- co_exclu %>%
  filter(total_sites > 50)
filt_ocur <- co_ocur %>%
  filter(total_sites > 50)

# radio entre sitios con mags y sitios con bgcs para casos de co-exclusion, que esten cerca de 0
ratio_plot <- filt_exclu %>%
  mutate(
    ratio = log2(mag_sites / bgc_sites)  # pseudoconteo para evitar log(0)
  )

# eliminar casos de co-ocurrencia donde el bgc pertenezca al mismo mag
meta_bgcs <- meta_bgcs %>%    # agregar columna de motus a meta_bgcs 
  left_join(meta_mags %>% select(Genome, mOTUs_Species_Cluster), by = "Genome")

filt_ocur <- filt_ocur %>%  #filtrar
  anti_join(meta_bgcs, by = c("Mags" = "mOTUs_Species_Cluster", "Bgcs" = "gcf"))

```








```{r check, eval=FALSE}
# 1138 mOTUs of only 1 MAG representative 
meta_mags %>%
  group_by(mOTUs.Species.Cluster) %>%                     
  summarise(n = n()) %>%                 
  filter(n == 1)  
# 2564 gcfs of only 1 BGC representative 
bgcs_sites %>%
  group_by(gcf) %>%                     
  summarise(n = n()) %>%                 
  filter(n == 1)  

names(which(table(meta_mags$mOTUs.Species.Cluster) == 1))



setdiff(motus_by_sites$station, gcfs_by_sites$station)
setdiff(meta_mags$station, bgcs_sites$station)
```




